<!DOCTYPE html>
<html lang="en">

<head>
    <title>3D Model-Bird</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #bfe3dd;
            color: #000;

            width: 100vw;
            height: 100vh;
            margin: 0;
            background: black;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <script type="module">
        import * as THREE from './build/three.module.js';
        import Stats from './jsm/libs/stats.module.js';

        import { OrbitControls } from './jsm/controls/OrbitControls.js';

        import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from './jsm/loaders/DRACOLoader.js';

        let mixer, mixer1, mixer2, mixer3, mixer4, mixerTokyo;

        //rain, cloud
        let cloudParticles = [], flash, rain, rainGeo, rainCount = 15000;


        init();
        function init() {
        
        }
        const clock = new THREE.Clock();
        const container = document.getElementById('container');

        const stats = new Stats();
        container.appendChild(stats.dom);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        //
        renderer.shadowMap.enabled = true;


        const pmremGenerator = new THREE.PMREMGenerator(renderer);

        const scene = new THREE.Scene();
        //
        scene.background = new THREE.Color(0xc2d4f0);
        scene.fog = new THREE.Fog(0xc2d4f0, 500, 10000);

        //
        scene.add(new THREE.AmbientLight(0x666666));

        const light = new THREE.DirectionalLight(0xdfebff, 1);
        light.position.set(50, 200, 100);
        light.position.multiplyScalar(1.3);

        light.castShadow = true;

        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;

        const d = 300;

        light.shadow.camera.left = - d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = - d;

        light.shadow.camera.far = 1000;

        scene.add(light);

        const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(1000, 50, 1500);


        // ground
        const texture_loader = new THREE.TextureLoader();
        const groundTexture = texture_loader.load('terrain/grasslight-big.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(25, 25);
        groundTexture.anisotropy = 16;
        groundTexture.encoding = THREE.sRGBEncoding;

        const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });

        let mesh = new THREE.Mesh(new THREE.PlaneGeometry(20000, 20000), groundMaterial);
        mesh.position.y = -250;
        mesh.rotation.x = - Math.PI / 2;
        mesh.receiveShadow = true;
        scene.add(mesh);


        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0.5, 0);
        controls.update();
        controls.enablePan = false;
        controls.enableDamping = true;

        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('js/libs/draco/gltf/');

        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);
        loader.load('models/Stork.glb', function (gltf) {
            let model1 = gltf.scene;
            model1.position.set(911, 78, 1050);
            model1.rotation.set(0, -.3, 0);
            model1.scale.set(0.04, 0.04, 0.04);
            scene.add(model1);

            mixer = new THREE.AnimationMixer(model1);
            mixer.clipAction(gltf.animations[0]).play();
        }, undefined, function (e) {
            console.error(e);
        });


        loader.load('models/Stork.glb', function (gltf) {
            const model = gltf.scene;
            model.position.set(905, 75, 1050);
            model.rotation.set(0, -.3, 0);
            model.scale.set(0.03, 0.03, 0.03);
            scene.add(model);

            mixer1 = new THREE.AnimationMixer(model);
            mixer1.clipAction(gltf.animations[0]).play();

        }, undefined, function (e) {
            console.error(e);
        });

        loader.load('models/Stork.glb', function (gltf) {
            const model2 = gltf.scene;
            model2.position.set(918, 75, 1055);
            model2.rotation.set(0, -.3, 0);
            model2.scale.set(0.03, 0.03, 0.03);
            scene.add(model2);

            mixer2 = new THREE.AnimationMixer(model2);
            mixer2.clipAction(gltf.animations[0]).play();


        }, undefined, function (e) {
            console.error(e);
        });

        loader.load('models/Stork.glb', function (gltf) {
            const model = gltf.scene;
            model.position.set(900, 72, 1050);
            model.rotation.set(0, -.3, 0);
            model.scale.set(0.03, 0.03, 0.03);
            scene.add(model);

            mixer3 = new THREE.AnimationMixer(model);
            mixer3.clipAction(gltf.animations[0]).play();


        }, undefined, function (e) {
            console.error(e);
        });

        loader.load('models/Stork.glb', function (gltf) {
            const model = gltf.scene;
            model.position.set(925, 72, 1058);
            model.rotation.set(0, -.3, 0);
            model.scale.set(0.03, 0.03, 0.03);
            scene.add(model);

            mixer4 = new THREE.AnimationMixer(model);
            mixer4.clipAction(gltf.animations[0]).play();

        }, undefined, function (e) {
            console.error(e);
        });

        //building
        loader.setDRACOLoader(dracoLoader);
        loader.load('models/LittlestTokyo.glb', function (gltf) {

            const model = gltf.scene;
            model.position.set(500, -110, 0);
            model.rotation.set(0, 3, 0);
            model.scale.set(0.5, 0.7, 0.5);
            scene.add(model);

            mixerTokyo = new THREE.AnimationMixer(model);
            mixerTokyo.clipAction(gltf.animations[0]).play();

            animate();
        }, undefined, function (e) {
            console.error(e);
        });

        //
        flash = new THREE.PointLight(0x062d89, 30, 500, 1.7);
        flash.position.set(200, 300, 600);
        scene.add(flash);

        // scene.fog = new THREE.FogExp2(0xffffff, 0.002);
        //  renderer.setClearColor(scene.fog.color);

        //rain
        // rainGeo = new THREE.Geometry();
        // for (let i = 0; i < rainCount; i++) {
        //     rainDrop = new THREE.Vector3(
        //         Math.random() * 400 - 200,
        //         Math.random() * 500 - 250,
        //         Math.random() * 400 - 200
        //     );
        //     rainDrop.velocity = {};
        //     rainDrop.velocity = 0;
        //     rainGeo.vertices.push(rainDrop);
        // }
        // rainMaterial = new THREE.PointsMaterial({
        //     color: 0xaaaaaa,
        //     size: 0.1,
        //     transparent: true
        // });
        // rain = new THREE.Points(rainGeo, rainMaterial);

        rainGeo = new THREE.BufferGeometry();
        // create a simple square shape. We duplicate the top left and bottom right
        // vertices because each vertex needs to appear once per triangle.
        const vertices = new Float32Array([
            -1.0, -1.0, 1.0,
            1.0, -1.0, 1.0,
            1.0, 1.0, 1.0,

            1.0, 1.0, 1.0,
            -1.0, 1.0, 1.0,
            -1.0, -1.0, 1.0
        ]);

        // itemSize = 3 because there are 3 values (components) per vertex
        rainGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        rain = new THREE.Mesh(rainGeo, material);

        scene.add(rain);
        //cloud
        texture_loader.load("texture/smoke.png", function (texture) {
            let cloudGeo = new THREE.PlaneBufferGeometry(500, 500);
            let cloudMaterial = new THREE.MeshLambertMaterial({
                map: texture,
                transparent: true
            });

            let cloud = new THREE.Mesh(cloudGeo, cloudMaterial);
            cloud.position.set(200, 300, 600);
            cloud.rotation.set(1.6, -.003, 3);
            cloud.scale.set(0.9, 0.9, 0.9);
            cloud.material.opacity = 0.4;
            cloudParticles.push(cloud);
            scene.add(cloud);

            let cloud_2 = new THREE.Mesh(cloudGeo, cloudMaterial);
            cloud_2.position.set(500, 300, 0);
            cloud_2.rotation.set(1.6, -.003, 3);
            cloud_2.scale.set(0.9, 0.9, 0.9);
            cloud_2.material.opacity = 0.4;
            cloudParticles.push(cloud_2);
            scene.add(cloud_2);
        });



        window.onresize = function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };


        function animate() {
            //rain and cloud
            cloudParticles.forEach(p => {
                p.rotation.z -= 0.002;
            });
            // rainGeo.vertices.forEach(p => {
            //     p.velocity -= 0.1 + Math.random() * 0.1;
            //     p.y += p.velocity;
            //     if (p.y < -200) {
            //         p.y = 200;
            //         p.velocity = 0;
            //     }
            // });
            rainGeo.verticesNeedUpdate = true;
            rain.rotation.y += 0.002;
            if (Math.random() > 0.93 || flash.power > 100) {
                if (flash.power < 100)
                    // flash.position.set(
                    //     Math.random() * 400,
                    //     300 + Math.random() * 200,
                    //     100
                    // );
                    flash.position.set(200, 100, 600);
                flash.power = 50 + Math.random() * 500;
            }

            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            mixer.update(delta);
            mixer1.update(delta);
            mixer2.update(delta);
            mixer3.update(delta);
            mixer4.update(delta);
            mixerTokyo.update(delta);
            controls.update();
            stats.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>